<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dawg Pile - Match 3</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{display:flex;justify-content:center;align-items:center;min-height:100vh;background:#2a4858;font-family:'Arial',sans-serif;overflow:hidden;}
#game{position:relative;}
canvas{display:block;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);}
#ui{position:absolute;top:20px;left:20px;right:20px;display:flex;justify-content:space-between;align-items:center;color:#fff;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px rgba(0,0,0,0.5);pointer-events:none;}
#title-screen,#gameover-screen{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(0,0,0,0.7);border-radius:12px;}
#title-screen h1,#gameover-screen h1{color:#fff;font-size:48px;margin-bottom:20px;text-shadow:3px 3px 6px rgba(0,0,0,0.8);}
#title-screen p{color:#fff;font-size:18px;margin-bottom:30px;text-align:center;max-width:500px;line-height:1.6;}
button{background:#ff6b35;color:#fff;border:none;padding:15px 40px;font-size:20px;font-weight:bold;border-radius:8px;cursor:pointer;box-shadow:0 4px 12px rgba(0,0,0,0.3);transition:all 0.2s;pointer-events:auto;}
button:hover{background:#ff8555;transform:translateY(-2px);box-shadow:0 6px 16px rgba(0,0,0,0.4);}
button:active{transform:translateY(0);}
#final-score{color:#ffd700;font-size:36px;margin:10px 0;}
</style>
</head>
<body>
<div id="game">
<canvas id="canvas" width="720" height="560"></canvas>
<div id="ui">
<div>Score: <span id="score">0</span></div>
<div id="rotate-hint" style="font-size:16px;opacity:0.8;">Click to rotate</div>
</div>
<div id="title-screen">
<h1>üêï DAWG PILE üêï</h1>
<p>Stack the dogs and match 3 or more of the same breed!<br>Click to rotate before dropping.<br>Tap two adjacent dogs to swap.</p>
<button id="startBtn">START GAME</button>
</div>
<div id="gameover-screen" style="display:none;">
<h1>GAME OVER</h1>
<div id="final-score">0</div>
<button id="restartBtn">PLAY AGAIN</button>
</div>
</div>
<script>
// This will be populated with the full game code

// ============================================================
// IMAGES
// ============================================================
const bgImg = new Image();
bgImg.src = 'img/background-v1.webp';
let bgLoaded = false;
bgImg.onload = () => bgLoaded = true;

const treeImg = new Image();
treeImg.src = 'img/tree.webp';
let treeLoaded = false;
treeImg.onload = () => treeLoaded = true;

const tennisImg = new Image();
tennisImg.src = 'img/tennis-ball.webp';
let tennisLoaded = false;
tennisImg.onload = () => tennisLoaded = true;

// Dog breed images
const dogImages = {};
const dogNames = ['chihuahua', 'corgi', 'dachshund', 'frenchie', 'german-sheppard', 'golden-retriever', 'husky', 'mutt', 'poodle', 'sheep-dog'];
dogImages['chihuahua'] = new Image(); dogImages['chihuahua'].src = 'img/dogs/sitting/chihuahua-sitting.webp';
dogImages['corgi'] = new Image(); dogImages['corgi'].src = 'img/dogs/sitting/corgie-sitting.webp';
dogImages['dachshund'] = new Image(); dogImages['dachshund'].src = 'img/dogs/sitting/dachshund-sitting.webp';
dogImages['frenchie'] = new Image(); dogImages['frenchie'].src = 'img/dogs/sitting/frenchie-sitting.webp';
dogImages['german-sheppard'] = new Image(); dogImages['german-sheppard'].src = 'img/dogs/sitting/german-sitting.webp';
dogImages['golden-retriever'] = new Image(); dogImages['golden-retriever'].src = 'img/dogs/sitting/golden-sitting.webp';
dogImages['husky'] = new Image(); dogImages['husky'].src = 'img/dogs/sitting/huskie-sitting.webp';
dogImages['mutt'] = new Image(); dogImages['mutt'].src = 'img/dogs/sitting/mutt-sitting.webp';
dogImages['poodle'] = new Image(); dogImages['poodle'].src = 'img/dogs/sitting/poodle-sitting.webp';
dogImages['sheep-dog'] = new Image(); dogImages['sheep-dog'].src = 'img/dogs/sitting/sheepdog-sitting.webp';

// ============================================================
// CONSTANTS
// ============================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 720, H = 560;
const GRID_COLS = 6;
const GRID_ROWS = 10;
const CELL_W = 60;
const CELL_H = 60;
const GRID_LEFT = (W - GRID_COLS * CELL_W) / 2;
const GRID_TOP = 80;

// ============================================================
// GAME STATE
// ============================================================
let grid = []; // 2D array of {breed, orientation} or null
let score = 0;
let gameRunning = false;
let currentDog = null; // {breed, orientation: 'h' or 'v'}
let dogX = GRID_COLS / 2;
let dogY = -2;
let dropping = false;
let selectedCell = null; // {row, col} for swap mechanic
let matchingCells = []; // Cells currently matching
let animatingMatch = false;

// ============================================================
// GRID FUNCTIONS
// ============================================================
function initGrid() {
  grid = [];
  for(let r = 0; r < GRID_ROWS; r++) {
    grid[r] = [];
    for(let c = 0; c < GRID_COLS; c++) {
      grid[r][c] = null;
    }
  }
}

function getCell(row, col) {
  if(row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS) return null;
  return grid[row][col];
}

function setCell(row, col, value) {
  if(row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS) {
    grid[row][col] = value;
  }
}

// Check if dog placement is valid
function canPlace(row, col, orientation) {
  if(orientation === 'v') {
    // 2 cells vertical (2 rows, 1 col)
    return getCell(row, col) === null && getCell(row + 1, col) === null;
  } else {
    // 2 cells horizontal (1 row, 2 cols)
    return getCell(row, col) === null && getCell(row, col + 1) === null;
  }
}

// Place dog on grid
function placeDog(row, col, breed, orientation) {
  const dogData = {breed, orientation};
  if(orientation === 'v') {
    setCell(row, col, dogData);
    setCell(row + 1, col, dogData);
  } else {
    setCell(row, col, dogData);
    setCell(row, col + 1, dogData);
  }
}

// ============================================================
// MATCH-3 LOGIC
// ============================================================
function findMatches() {
  const matches = new Set();
  
  // Check horizontal matches
  for(let r = 0; r < GRID_ROWS; r++) {
    for(let c = 0; c < GRID_COLS - 2; c++) {
      const cell1 = getCell(r, c);
      const cell2 = getCell(r, c + 1);
      const cell3 = getCell(r, c + 2);
      
      if(cell1 && cell2 && cell3 && 
         cell1.breed === cell2.breed && cell2.breed === cell3.breed) {
        matches.add(`${r},${c}`);
        matches.add(`${r},${c+1}`);
        matches.add(`${r},${c+2}`);
        
        // Check for longer matches
        let c2 = c + 3;
        while(c2 < GRID_COLS) {
          const cell = getCell(r, c2);
          if(cell && cell.breed === cell1.breed) {
            matches.add(`${r},${c2}`);
            c2++;
          } else break;
        }
      }
    }
  }
  
  // Check vertical matches
  for(let c = 0; c < GRID_COLS; c++) {
    for(let r = 0; r < GRID_ROWS - 2; r++) {
      const cell1 = getCell(r, c);
      const cell2 = getCell(r + 1, c);
      const cell3 = getCell(r + 2, c);
      
      if(cell1 && cell2 && cell3 && 
         cell1.breed === cell2.breed && cell2.breed === cell3.breed) {
        matches.add(`${r},${c}`);
        matches.add(`${r+1},${c}`);
        matches.add(`${r+2},${c}`);
        
        // Check for longer matches
        let r2 = r + 3;
        while(r2 < GRID_ROWS) {
          const cell = getCell(r2, c);
          if(cell && cell.breed === cell1.breed) {
            matches.add(`${r2},${c}`);
            r2++;
          } else break;
        }
      }
    }
  }
  
  return Array.from(matches).map(s => {
    const [r, c] = s.split(',').map(Number);
    return {row: r, col: c};
  });
}

function removeMatches(matches) {
  matches.forEach(({row, col}) => {
    setCell(row, col, null);
  });
  score += matches.length * 10;
  updateUI();
}

function applyGravity() {
  let moved = false;
  for(let c = 0; c < GRID_COLS; c++) {
    for(let r = GRID_ROWS - 1; r >= 0; r--) {
      if(getCell(r, c) === null) {
        // Find dog above
        for(let r2 = r - 1; r2 >= 0; r2--) {
          if(getCell(r2, c) !== null) {
            setCell(r, c, getCell(r2, c));
            setCell(r2, c, null);
            moved = true;
            break;
          }
        }
      }
    }
  }
  return moved;
}

async function processMatches() {
  const matches = findMatches();
  if(matches.length > 0) {
    matchingCells = matches;
    animatingMatch = true;
    
    await new Promise(resolve => setTimeout(resolve, 500));
    
    removeMatches(matches);
    matchingCells = [];
    animatingMatch = false;
    
    await new Promise(resolve => setTimeout(resolve, 200));
    
    while(applyGravity()) {
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    // Check for cascades
    await processMatches();
  }
}

// ============================================================
// SWAP MECHANIC
// ============================================================
function swapCells(row1, col1, row2, col2) {
  const temp = getCell(row1, col1);
  setCell(row1, col1, getCell(row2, col2));
  setCell(row2, col2, temp);
}

function areAdjacent(r1, c1, r2, c2) {
  return (Math.abs(r1 - r2) === 1 && c1 === c2) ||
         (Math.abs(c1 - c2) === 1 && r1 === r2);
}

// ============================================================
// GAME FLOW
// ============================================================
function startGame() {
  initGrid();
  score = 0;
  updateUI();
  currentDog = spawnDog();
  dogX = Math.floor(GRID_COLS / 2);
  dogY = -2;
  dropping = false;
  selectedCell = null;
  gameRunning = true;
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
}

function spawnDog() {
  const breed = dogNames[Math.floor(Math.random() * dogNames.length)];
  return {breed, orientation: 'v'};
}

function rotateDog() {
  if(currentDog && !dropping) {
    currentDog.orientation = currentDog.orientation === 'v' ? 'h' : 'v';
  }
}

function dropDog() {
  if(dropping || !currentDog) return;
  
  const col = Math.floor(dogX);
  
  // Find where it lands
  let landRow = GRID_ROWS;
  for(let r = 0; r < GRID_ROWS; r++) {
    if(!canPlace(r, col, currentDog.orientation)) {
      landRow = r - 1;
      break;
    }
  }
  
  // Check if valid placement
  if(landRow < 0 || !canPlace(landRow, col, currentDog.orientation)) {
    gameOver();
    return;
  }
  
  placeDog(landRow, col, currentDog.breed, currentDog.orientation);
  dropping = true;
  
  setTimeout(async () => {
    await processMatches();
    currentDog = spawnDog();
    dogX = Math.floor(GRID_COLS / 2);
    dogY = -2;
    dropping = false;
    
    // Check if any moves possible
    if(!canPlace(0, 0, 'v') && !canPlace(0, 0, 'h')) {
      let canPlaceAnywhere = false;
      for(let r = 0; r < GRID_ROWS; r++) {
        for(let c = 0; c < GRID_COLS; c++) {
          if(canPlace(r, c, 'v') || canPlace(r, c, 'h')) {
            canPlaceAnywhere = true;
            break;
          }
        }
        if(canPlaceAnywhere) break;
      }
      if(!canPlaceAnywhere) gameOver();
    }
  }, 400);
}

function gameOver() {
  gameRunning = false;
  document.getElementById('final-score').textContent = score;
  document.getElementById('gameover-screen').style.display = 'flex';
}

function updateUI() {
  document.getElementById('score').textContent = score;
}

// ============================================================
// INPUT
// ============================================================
canvas.addEventListener('click', (e) => {
  if(!gameRunning) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Check if clicking on current dog (rotate)
  if(!dropping && currentDog) {
    const dogScreenX = GRID_LEFT + dogX * CELL_W;
    const dogScreenY = GRID_TOP + dogY * CELL_H;
    const dogW = currentDog.orientation === 'h' ? CELL_W * 2 : CELL_W;
    const dogH = currentDog.orientation === 'v' ? CELL_H * 2 : CELL_H;
    
    if(x >= dogScreenX && x < dogScreenX + dogW &&
       y >= dogScreenY && y < dogScreenY + dogH) {
      rotateDog();
      return;
    }
  }
  
  // Check if clicking on grid cell (for swapping)
  if(x >= GRID_LEFT && x < GRID_LEFT + GRID_COLS * CELL_W &&
     y >= GRID_TOP && y < GRID_TOP + GRID_ROWS * CELL_H && !animatingMatch) {
    const col = Math.floor((x - GRID_LEFT) / CELL_W);
    const row = Math.floor((y - GRID_TOP) / CELL_H);
    
    if(getCell(row, col)) {
      if(selectedCell) {
        // Try to swap
        if(areAdjacent(selectedCell.row, selectedCell.col, row, col)) {
          swapCells(selectedCell.row, selectedCell.col, row, col);
          setTimeout(() => processMatches(), 200);
        }
        selectedCell = null;
      } else {
        selectedCell = {row, col};
      }
    }
  }
  
  // Otherwise drop the dog
  if(!dropping && currentDog) {
    dropDog();
  }
});

canvas.addEventListener('mousemove', (e) => {
  if(!gameRunning || dropping || !currentDog) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  
  dogX = Math.max(0, Math.min(GRID_COLS - (currentDog.orientation === 'h' ? 2 : 1),
    (x - GRID_LEFT) / CELL_W));
});

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

// ============================================================
// DRAW
// ============================================================
function draw() {
  // Background
  if(bgLoaded) {
    ctx.drawImage(bgImg, 0, 0, W, H);
  } else {
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(0, 0, W, H);
  }
  
  // Grid background
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(GRID_LEFT, GRID_TOP, GRID_COLS * CELL_W, GRID_ROWS * CELL_H);
  
  // Grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  for(let c = 0; c <= GRID_COLS; c++) {
    const x = GRID_LEFT + c * CELL_W;
    ctx.beginPath();
    ctx.moveTo(x, GRID_TOP);
    ctx.lineTo(x, GRID_TOP + GRID_ROWS * CELL_H);
    ctx.stroke();
  }
  for(let r = 0; r <= GRID_ROWS; r++) {
    const y = GRID_TOP + r * CELL_H;
    ctx.beginPath();
    ctx.moveTo(GRID_LEFT, y);
    ctx.lineTo(GRID_LEFT + GRID_COLS * CELL_W, y);
    ctx.stroke();
  }
  
  // Draw placed dogs
  for(let r = 0; r < GRID_ROWS; r++) {
    for(let c = 0; c < GRID_COLS; c++) {
      const cell = getCell(r, c);
      if(cell) {
        const x = GRID_LEFT + c * CELL_W;
        const y = GRID_TOP + r * CELL_H;
        
        // Highlight matching cells
        const isMatching = matchingCells.some(m => m.row === r && m.col === c);
        if(isMatching) {
          ctx.fillStyle = 'rgba(255,255,0,0.4)';
          ctx.fillRect(x, y, CELL_W, CELL_H);
        }
        
        // Highlight selected cell
        if(selectedCell && selectedCell.row === r && selectedCell.col === c) {
          ctx.fillStyle = 'rgba(100,200,255,0.5)';
          ctx.fillRect(x, y, CELL_W, CELL_H);
        }
        
        // Draw dog image
        const img = dogImages[cell.breed];
        if(img && img.complete) {
          if(cell.orientation === 'v') {
            ctx.drawImage(img, x, y, CELL_W, CELL_H * 2);
          } else {
            ctx.save();
            ctx.translate(x + CELL_W, y);
            ctx.rotate(Math.PI / 2);
            ctx.drawImage(img, 0, -CELL_W, CELL_H * 2, CELL_W);
            ctx.restore();
          }
        }
      }
    }
  }
  
  // Draw current dog
  if(currentDog && !dropping && gameRunning) {
    const x = GRID_LEFT + dogX * CELL_W;
    const y = GRID_TOP + dogY * CELL_H;
    const img = dogImages[currentDog.breed];
    
    if(img && img.complete) {
      ctx.globalAlpha = 0.7;
      if(currentDog.orientation === 'v') {
        ctx.drawImage(img, x, y, CELL_W, CELL_H * 2);
      } else {
        ctx.save();
        ctx.translate(x + CELL_W, y);
        ctx.rotate(Math.PI / 2);
        ctx.drawImage(img, 0, -CELL_W, CELL_H * 2, CELL_W);
        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }
  }
  
  // Draw tree
  if(treeLoaded) {
    const treeH = H * 0.9;
    const treeW = treeImg.width * (treeH / treeImg.height);
    ctx.drawImage(treeImg, 0, H - treeH, treeW, treeH);
  }
  
  requestAnimationFrame(draw);
}

// ============================================================
// START
// ============================================================
draw();
console.log("Dawg Pile Match-3 Ready!");

</script>
</body>
</html>
